<h2>Работа с GIT</h2>
<h3>Ветки</h3>
<ul>
    <li><code> git branch </code> - команда позволяет посмотреть список веток в репозитории (ветка - это альтернативная линия разработки). Перед текущей веткой (в которой ведется разработка) будет стоять *</li>
    <li><code> git branch branch_name </code> - создание новой ветки</li>
    <li><code> git checkout branch_name </code> - переключаемся на новую ветку</li>
    <li><code>  git checkout -b branch_name </code> - создание новой ветки и переключение на нее</li>
    <li><code> git fetch </code> - выгрузка всех изменений из удаленного репозитория (VCS -> Git -> Fetch в IDEA)</li>
    <!--<li><code>  </code> - </li>-->
</ul>
<h3>Откат изменений</h3>
<p>Если нужно изменить историю зафиксированных изменений, то загрузку на github нужно сделать в режиме --force<br> <code> git push origin +master </code></p>
<ul>
    <li>
        <strong>git reset --soft</strong><br>
        Возьмем для примера ветку:<br>
        - A - B - C (master)<br>
        HEAD указывает на C и индекс совпадает с C. <br>
        Если выполнить команду <code> git reset --soft B </code> <br>
        HEAD будет указывать на B и изменения из коммита C будут в индексе, как будто вы их добавили командой git add. Если вы сейчас выполните git commit вы получите коммит полностью идентичный C.
    </li>
    <li>
        <strong>git reset --mixed</strong><br>
        Режим --mixed используется по умолчанию, т.е. <code> git reset --mixed = git reset </code><br>
        Вернемся к тем же начальным условиям:<br>
        - A - B - C (master) <br>
        Выполнив <code> git reset --mixed B </code> или <code> git reset B </code><br>
        HEAD опять же будет указывать на B, но на этот раз изменения из С не будут в индексе и если вы запустите здесь git commit ничего не произойдет т.к. ничего нет в индексе. У нас есть все изменения из С, но если запустить git status то вы увидите, что все изменения not staged. Чтобы их закоммитить нужно сначала добавить их в индекс командой git add и только после этого git commit.
    </li>
    <li>
        <strong>git reset --hard</strong><br>
        Те же самые начальные условия:<br>
        - A - B - C (master)<br>
        Последний режим --hard также как и --mixed переместит HEAD на В и очистит индекс, но в отличие от --mixed жесткий reset изменит файлы в вашей рабочей директории. Если выполнить <code> git reset --hard B </code> <br>
        то изменения из С, равно как и незакоммиченные изменения, будут удалены и файлы в репозитории будут совпадать с B. Учитывая то, что этот режим подразумевает потерю изменений, вы всегда должны проверять git status перед тем как выполнить жесткий reset чтобы убедиться что нет незакоммиченных изменений(или они не нужны).
    </li>
</ul>